include("auto");
function bulbAI(){
	updateCoefs(getAliveAllies()+getAliveEnemies());
	_REACHABLE_CELLS = getReachableCells(getLeek(), getMP());
	var type = getEntityType(getLeek());
	var cell;
	var scores = [];
	var group;
	for (var chip in getChips()) {
		if(getCooldown(chip) > 0) continue;
		scores[chip] = [];
		if(_IS_POSITIV_EFFECTS[chip]){
			group = getAliveAllies();
		}else group = getAliveEnemies();
		for (var l in group) {
			var testCells = getChipEffectiveArea(chip, getCell(l), getCellToUseChip(chip, l));
			for (var c in testCells) {
				cell = myGetCellToUseItem(chip, c);
				if(cell != null){
					scores[chip][c] = getActionScore([chip, c]);
				}
			}
		}
	}
	debug("scores bulbe" + scores);
	playBestMove(findBestMove(scores));
	moveTowardCell(getSafestCell(sortMapForCells(_MAP_DANGER, _SELF)));
}
function scoreAllPossibleActions(){
	startOperationTest();
	updateCoefs(getAliveAllies()+getAliveEnemies());//scoring
	var stuff = filterInventory(getLeek());//mes chips triées avec mes cooldowns(jvais pas jouer un truc que jpeux pas utiliser) 
	var reachableCells = getLeek() == _SELF? _REACHABLE_CELLS: getReachableCells(getLeek(), getMP());//éviter de redéfinir mes cellules accessibles pcq jles ai déjà
	var scores = [];
	var actions = [];
	var testCells;
	var cell;
	var targets;
	var group;
	//start for weapons
	for (var w in getWeapons()) 
	{
		scores[w] = [];
		var area = _AREA[w];//getWeaponArea en moins cher
		for (var e in getAliveEnemies()) 
		{
			testCells = getWeaponEffectiveArea(w, getCell(e), getCellToUseWeapon(w, e));
			if(area == AREA_LASER_LINE || area == AREA_POINT) testCells = [getCell(e)];
			for (var c in testCells) 
			{
				cell = myGetCellToUseItem(w, c);
				if(cell != null)
				{
					scores[w][c] = getActionScore([w, c]);
				}
			}
		}
	}//end for weapons
	for (var chip : var bool in _DECODING_STUFF) 
	{
		if(_ISWEAP[chip]) continue;
		scores[chip] = [];
		if(getCooldown(chip) > 0) continue;
		if(_IS_POSITIV_EFFECTS[chip])
		{
			var minRange = _ITEM_MINRANGE[chip];
			var onlyBulb = _ISONLYBULB[chip];//ça sert à savoir sur quoi je teste (true si c'est que pour les bulbes, false si c'est que pour les poireaux, 
			//null sinon)
			var area = _AREA[chip];//getChipArea
			group = getAliveAllies();//vu que ç'est un effet positif on teste pas sur les enemis
			if(onlyBulb == false)//la on trie les trucs sur lesquels la chip n'a pas d'effet
			{
				for (var l in group) 
				{
					if(getEntityType(l) != ENTITY_LEEK_) removeElement(group, l);
				}
			}
			else if(onlyBulb == true)//idem
			{
				for (var l in group) 
				{
					if(getEntityType(l) == ENTITY_LEEK_) removeElement(group, l);
				}
			}
			if(minRange > 0) removeElement(group, getLeek());
			for (var l in group) 
			{
				testCells = getChipEffectiveArea(chip, getCell(l), getCellToUseChip(chip, l));
				for (var c in testCells) 
				{
					cell = myGetCellToUseItem(chip, c);
					if(cell != null) 
					{
						if(c == getCell()) scores[chip]["selfCell"] = getActionScore([chip, c]);
						else scores[chip][c] = getActionScore([chip,c]);
					}
				}
			}
		}else
		{
			var area = _AREA[chip];
			var onlyBulb = _ISONLYBULB[chip];
			group = getAliveEnemies();
			if(onlyBulb == false)//même principe que pour les alliés
			{
				for (var l in group) 
				{
					if(getEntityType(l) != ENTITY_LEEK_) removeElement(group, l);
				}
			}
			else if(onlyBulb == true)
			{
				for (var l in group) 
				{
					if(getEntityType(l) == ENTITY_LEEK_) removeElement(group, l);
				}
			}
			for (var l in group) 
			{
				testCells = getChipEffectiveArea(chip, getCell(l), getCellToUseChip(chip, l));
				for (var c in testCells) 
				{
					cell = myGetCellToUseItem(chip, c);
					if(cell != null) {
						scores[chip][c] = getActionScore([chip,c]);
					}
				}
			}
		}
	}//end for normal chip
	for (var item : var bool in _ENCODING_STUFF) {
		if(_TO_REMOVE_TO_STUFF[item] && getCooldown(item) == 0 && _IN_ALGO[item] == null) {
			scores[item] = [];
			scores[item]["selfCell"] = getSpecialChipScore(item);
		}
	}
	stopOperationTest("scoring des moves");
	return @scores;
}
function findBestAction(@scores){
	var bestScore = 0;
	var bestAction = [];
	for(var w in getWeapons()){
		for (var cell : var score in scores[w]) {
			if(score > bestScore){
				debug("score testé " + score + "bestScore " + bestScore);
				if(score > 0) bestScore = score;
				if(score > 0)bestAction = [w, cell];
			}
		}
	}//end for weapons
	for (var chip in getChips()) {
		if(_IN_ALGO[chip] == false) continue;
		for (var cell : var score in scores[chip]) {
			if(score > bestScore){
				if(score > 0)bestScore = score;
				if(score > 0)bestAction = [chip, cell];
			}
		}
	}
	return bestAction;
}
function findBestMove(@scores){
	var move = [];
	var selfTP = getTP();
	push(move, findBestAction(scores));
	selfTP -= _ITEMCOST[move[0][0]];
	if(getWeapon() != move[0][0] && _ISWEAP[move[0][0]]) selfTP -= 1; 
	if(_ITEM_HAVECD[move[0][0]]) scores[move[0][0]] = [];
	for (var item : var bool in _ENCODING_STUFF) {
		if(selfTP < _ITEMCOST[item]) scores[item] = [];
	}
	push(move, findBestAction(scores));
	selfTP -= _ITEMCOST[move[1][0]];
	if(_ITEM_HAVECD[move[1][0]]) scores[move[1][0]] = [];
	for (var item : var bool in _ENCODING_STUFF) {
		if(selfTP < _ITEMCOST[item]) scores[item] = [];
	}
	var action = findBestAction(scores);
	if(action != null) push(move, action);
	selfTP -= _ITEMCOST[move[2][0]];
	if(_ITEM_HAVECD[move[2][0]]) scores[move[2][0]] = [];
	for (var item : var bool in _ENCODING_STUFF) {
		if(selfTP < _ITEMCOST[item]) scores[item] = [];
	}
	action = findBestAction(scores);
	if(action != null) push(move, action);
	selfTP -= _ITEMCOST[move[3][0]];
	if(_ITEM_HAVECD[move[3][0]]) scores[move[3][0]] = [];
	for (var item : var bool in _ENCODING_STUFF) {
		if(selfTP < _ITEMCOST[item]) scores[item] = [];
	}
	debug("bestMove " + move);
	return move;
}
function playBestMove(@bestMove){
	var delayedSummon = [];
	for (var action in bestMove) {
		if(action[0] == CHIP_PUNY_BULB|| 
			action[0] == CHIP_ROCKY_BULB||
			action[0] == CHIP_ICED_BULB ||
			action[0] == CHIP_HEALER_BULB||
			action[0] == CHIP_FIRE_BULB||
			action[0] == CHIP_METALLIC_BULB||
			action[0] == CHIP_LIGHTNING_BULB)
			{
				push(delayedSummon, action);
				continue;
			}
		if(count(action) == 0) continue;
		if(_ISWEAP[action[0]] && getWeapon() != action[0]) setWeapon(action[0]);
		if(action[1] != "selfCell") moveTowardCell(myGetCellToUseItem(action[0], action[1]));
		if(_ISWEAP[action[0]]) useWeaponOnCell(action[1]);
		else{
			if(action[1] == "selfCell") useChip(action[0], _SELF);
			else useChipOnCell(action[0], action[1]);
		}
		_REACHABLE_CELLS = getReachableCells(_SELF, getMP(_SELF));
	}
	moveTowardCell(getSafestCell(sortMapForCells(_MAP_DANGER, _SELF)));
	for (var chip in delayedSummon) {
		summon(chip[0], getCellToUseChip(chip[0], _SELF), bulbAI);
	}
}
