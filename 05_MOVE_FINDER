include("auto");
function bulbAI(){
	var type = getEntityType(getLeek());
	if(type != "ENTITY_ROCKY_BULB" || "ENTITY_HEALER_BULB") var group = getAliveEnemies();
	else var group = getAliveAllies();
}
function scoreAllPossibleActions(){
	startOperationTest();
	updateCoefs(getAliveAllies()+getAliveEnemies());//scoring
	var stuff = filterInventory(getLeek());//mes chips triées avec mes cooldowns(jvais pas jouer un truc que jpeux pas utiliser) 
	var reachableCells = getLeek() == _SELF? _REACHABLE_CELLS: getReachableCells(getLeek(), getMP());//éviter de redéfinir mes cellules accessibles pcq jles ai déjà
	var scores = [];
	var actions = [];
	var testCells;
	var cell;
	var targets;
	var group;
	//start for weapons
	for (var w in getWeapons()) 
	{
		scores[w] = [];
		var area = _AREA[w];//getWeaponArea en moins cher
		for (var e in getAliveEnemies()) 
		{
			testCells = getWeaponEffectiveArea(w, getCell(e));
			for (var c in testCells) 
			{
				cell = myGetCellToUseItem(w, c);
				if(cell != null)
				{
					scores[w][c] = getActionScore([w, c]);
				}
			}
		}
	}//end for weapons
	for (var chip : var bool in _DECODING_STUFF) 
	{
		if(_ISWEAP[chip]) continue;
		scores[chip] = [];
		if(getCooldown(chip) > 0) continue;
		if(_IS_POSITIV_EFFECTS[chip])
		{
			var minRange = _ITEM_MINRANGE[chip];
			var onlyBulb = _ISONLYBULB[chip];//ça sert à savoir sur quoi je teste (true si c'est que pour les bulbes, false si c'est que pour les poireaux, 
			//null sinon)
			var area = _AREA[chip];//getChipArea
			group = getAliveAllies();//vu que ç'est un effet positif on teste pas sur les enemis
			if(onlyBulb == false)//la on trie les trucs sur lesquels la chip n'a pas d'effet
			{
				for (var l in group) 
				{
					if(getEntityType(l) != ENTITY_LEEK_) removeElement(group, l);
				}
			}
			else if(onlyBulb == true)//idem
			{
				for (var l in group) 
				{
					if(getEntityType(l) == ENTITY_LEEK_) removeElement(group, l);
				}
			}
			if(minRange > 0) removeElement(group, getLeek());
			for (var l in group) 
			{
				testCells = getChipEffectiveArea(chip, getCell(l));
				for (var c in testCells) 
				{
					cell = myGetCellToUseItem(chip, c);
					if(cell != null) 
					{
						if(c == getCell()) scores[chip]["selfCell"] = getActionScore([chip, c]);
						else scores[chip][c] = getActionScore([chip,c]);
					}
				}
			}
		}else
		{
			var area = _AREA[chip];
			var onlyBulb = _ISONLYBULB[chip];
			group = getAliveEnemies();
			if(onlyBulb == false)//même principe que pour les alliés
			{
				for (var l in group) 
				{
					if(getEntityType(l) != ENTITY_LEEK_) removeElement(group, l);
				}
			}
			else if(onlyBulb == true)
			{
				for (var l in group) 
				{
					if(getEntityType(l) == ENTITY_LEEK_) removeElement(group, l);
				}
			}
			for (var l in group) 
			{
				testCells = getChipEffectiveArea(chip, getCell(l));
				for (var c in testCells) 
				{
					cell = myGetCellToUseItem(chip, c);
					if(cell != null) {
						scores[chip][c] = getActionScore([chip,c]);
					}
				}
			}
		}
	}//end for normal chip
	for (var item : var bool in _ENCODING_STUFF) {
		if(_IN_ALGO[item]) continue;
		if(_TO_REMOVE_TO_STUFF[item] && getCooldown(item) == 0) scores[item] = getSpecialChipScore(item);
	}
	stopOperationTest("scoring des moves");
	debug(@scores);
	return @scores;
}
debug(scoreAllPossibleActions()+"le score des actions");
function findBestAction(@scores){
	var bestScore = 0;
	var bestAction = [];
	for(var w in getWeapon()){
		for (var cell : var score in scores[w]) {
			if(score > bestScore){
				bestScore = score;
				bestAction = [w, cell];
			}
		}
	}//end for weapons
	for (var chip in getChips()) {
		if(_DECODING_STUFF[chip] == null) continue;
		for (var cell : var score in scores[chip]) {
			if(score > bestScore){
				bestScore = score;
				bestAction = [chip, cell];
			}
		}
	}
	return bestAction;
}
function findBestMove(@scores){
	var move = [];
	var selfTP = getTP();
	push(move, findBestAction(scores));
	selfTP -= _ITEMCOST[move[0][0]];
	if(_ITEM_HAVECD[move[0][0]]) scores[move[0][0]] = [];
	for (var item : var bool in _ENCODING_STUFF) {
		if(selfTP < _ITEMCOST[item]) scores[item] = [];
	}
	push(move, findBestAction(scores));
	selfTP -= _ITEMCOST[move[1][0]];
	if(_ITEM_HAVECD[move[1][0]]) scores[move[1][0]] = [];
	for (var item : var bool in _ENCODING_STUFF) {
		if(selfTP < _ITEMCOST[item]) scores[item] = [];
	}
	var action = findBestAction(scores);
	if(action != null) push(move, action);
	selfTP -= _ITEMCOST[move[2][0]];
	if(_ITEM_HAVECD[move[2][0]]) scores[move[2][0]] = [];
	for (var item : var bool in _ENCODING_STUFF) {
		if(selfTP < _ITEMCOST[item]) scores[item] = [];
	}
	action = findBestAction(scores);
	if(action != null) push(move, action);
	selfTP -= _ITEMCOST[move[3][0]];
	if(_ITEM_HAVECD[move[3][0]]) scores[move[3][0]] = [];
	for (var item : var bool in _ENCODING_STUFF) {
		if(selfTP < _ITEMCOST[item]) scores[item] = [];
	}
	return move;
}
function playBestMove(@bestMove){
	for (var action in bestMove) {
		if(_ISWEAP[action[0]] && getWeapon() != action[0]) setWeapon(action[0]);
		if(action[1] != "selfCell") moveTowardCell(myGetCellToUseItem(action[0], action[1]));
		if(_ISWEAP[action[0]]) useWeaponOnCell(action[1]);
		else{
			if(action[1] == "selfCell") useChip(action[0], _SELF);
			else useChipOnCell(action[0], action[1]);
		}
	}
}
debug("bestMove" + findBestMove(scoreAllPossibleActions()));
